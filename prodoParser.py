#!/usr/bin/python2

# Begin -- grammar generated by Yapps
from __future__ import print_function
import sys, re
from yapps import runtime

class ProdoScanner(runtime.Scanner):
    patterns = [
        ("'loop'", re.compile('loop')),
        ("'while'", re.compile('while')),
        ("'by '", re.compile('by ')),
        ("'to'", re.compile('to')),
        ("':='", re.compile(':=')),
        ("'for'", re.compile('for')),
        ("'>='", re.compile('>=')),
        ("'<='", re.compile('<=')),
        ("'>'", re.compile('>')),
        ("'<'", re.compile('<')),
        ("'!='", re.compile('!=')),
        ("'=='", re.compile('==')),
        ("'xor'", re.compile('xor')),
        ("'or'", re.compile('or')),
        ("'and'", re.compile('and')),
        ("'no'", re.compile('no')),
        ("'yes'", re.compile('yes')),
        ("'else'", re.compile('else')),
        ("'elseif'", re.compile('elseif')),
        ("'\\\\|'", re.compile('\\|')),
        ("'if'", re.compile('if')),
        ("'stop'", re.compile('stop')),
        ("'next'", re.compile('next')),
        ("'conclude'", re.compile('conclude')),
        ('"fcn"', re.compile('fcn')),
        ('"%"', re.compile('%')),
        ('"/"', re.compile('/')),
        ("r'[*]'", re.compile('[*]')),
        ('"-"', re.compile('-')),
        ("r'[+]'", re.compile('[+]')),
        ('","', re.compile(',')),
        ("'\\\\]'", re.compile('\\]')),
        ("'\\\\['", re.compile('\\[')),
        ('"-="', re.compile('-=')),
        ('r"[+]="', re.compile('[+]=')),
        ('"%="', re.compile('%=')),
        ('"/="', re.compile('/=')),
        ('r"[*]="', re.compile('[*]=')),
        ('":="', re.compile(':=')),
        ('"\\\\)"', re.compile('\\)')),
        ('"\\\\("', re.compile('\\(')),
        ("'enum'", re.compile('enum')),
        ("'structure'", re.compile('structure')),
        ("'array'", re.compile('array')),
        ("'str'", re.compile('str')),
        ("'real'", re.compile('real')),
        ("'int'", re.compile('int')),
        ("'bool'", re.compile('bool')),
        ("'void'", re.compile('void')),
        ("''", re.compile('')),
        ('END', re.compile('$')),
        ('NEWLINE', re.compile('([\\n])+')),
        ('INT', re.compile('([0-9])+|([-][0-9])+')),
        ('REAL', re.compile('[0-9]+[.][0-9]+')),
        ('STRING', re.compile('"([^\\\\"]+|\\\\.)*"')),
        ('ID', re.compile('[a-zA-Z]([a-zA-Z0-9$_@])*')),
        ('TYPE', re.compile('[a-zA-Z_]')),
        ('FCN', re.compile('[@]([a-zA-Z0-9_])*')),
        ('INDENT', re.compile('([ ]{4})*')),
        ('END_BLOCK', re.compile('([ ])*end')),
        (' ', re.compile(' ')),
        ('~(.)*', re.compile('~(.)*')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{' ':None,'~(.)*':None,},str,*args,**kw)

class Prodo(runtime.Parser):
    Context = runtime.Context
    def super(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'super', [])
        global header
        header = 'from prodo import *;'
        code = ''
        while self._peek('END', '"fcn"', "'conclude'", "'next'", "'stop'", "'if'", "'for'", "'while'", "'loop'", "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', 'ID', context=_context) != 'END':
            statement = self.statement(_context)
            ender = self.ender(_context)
            code += statement
        END = self._scan('END', context=_context)
        return header + code

    def ender(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ender', [])
        _token = self._peek('NEWLINE', "''", context=_context)
        if _token == 'NEWLINE':
            NEWLINE = self._scan('NEWLINE', context=_context)
        else: # == "''"
            self._scan("''", context=_context)

    def type_name(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'type_name', [])
        _token = self._peek("'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', context=_context)
        if _token == "'void'":
            self._scan("'void'", context=_context)
            return 'void'
        elif _token == "'bool'":
            self._scan("'bool'", context=_context)
            return 'bool'
        elif _token == "'int'":
            self._scan("'int'", context=_context)
            return 'int'
        elif _token == "'real'":
            self._scan("'real'", context=_context)
            return 'float'
        elif _token == "'str'":
            self._scan("'str'", context=_context)
            return 'str'
        elif _token == "'array'":
            self._scan("'array'", context=_context)
            return 'list'
        elif _token == "'structure'":
            self._scan("'structure'", context=_context)
            return 'dict'
        elif _token == "'enum'":
            self._scan("'enum'", context=_context)
            return 'enum '
        else: # == 'TYPE'
            TYPE = self._scan('TYPE', context=_context)
            return TYPE

    def statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'statement', [])
        _token = self._peek('"fcn"', "'conclude'", "'next'", "'stop'", "'if'", "'for'", "'while'", "'loop'", "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', 'ID', context=_context)
        if _token not in ['"fcn"', "'conclude'", "'next'", "'stop'", "'if'", "'for'", "'while'", "'loop'"]:
            exp_statement = self.exp_statement(_context)
            return exp_statement
        elif _token == '"fcn"':
            fcn_definition = self.fcn_definition(_context)
            return fcn_definition
        elif _token not in ["'if'", "'for'", "'while'", "'loop'"]:
            jump_statement = self.jump_statement(_context)
            return jump_statement + ";"
        elif _token == "'if'":
            conditional_statement = self.conditional_statement(_context)
            return conditional_statement
        else: # in ["'for'", "'while'", "'loop'"]
            iterative_statement = self.iterative_statement(_context)
            return iterative_statement

    def exp_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'exp_statement', [])
        _token = self._peek("'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', 'ID', context=_context)
        if _token != 'ID':
            declaration_exp = self.declaration_exp(_context)
            return declaration_exp
        else: # == 'ID'
            identified_exp = self.identified_exp(_context)
            return identified_exp

    def identified_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'identified_exp', [])
        identifier = self.identifier(_context)
        A = ""
        _token = self._peek('"\\\\("', '":="', 'r"[*]="', '"/="', '"%="', 'r"[+]="', '"-="', context=_context)
        if _token != '"\\\\("':
            assignment_op = self.assignment_op(_context)
            O = assignment_op
            S = [identifier]
            additive_exp = self.additive_exp(_context)
            if (O != ""): additive_exp = identifier + assignment_op + additive_exp;
            for x in S: A += x + "=assign(" + x + "," + additive_exp + ");"
            return A
        else: # == '"\\\\("'
            self._scan('"\\\\("', context=_context)
            list_plain = self.list_plain(_context)
            self._scan('"\\\\)"', context=_context)
            return identifier + "("+list_plain+");"

    def declaration_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'declaration_exp', [])
        type_name = self.type_name(_context)
        identifier = self.identifier(_context)
        self._scan('":="', context=_context)
        S=[identifier + "=" ];SD = ""
        while self._peek('ID', 'INT', 'REAL', "'\\\\['", 'STRING', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', context=_context) == 'ID':
            identifier = self.identifier(_context)
            self._scan('":="', context=_context)
            S.append(identifier + "=" )
        additive_exp = self.additive_exp(_context)
        for i in range(0, len(S)):S[i]+=type_name+"("+additive_exp+")"
        for x in S: SD += x + ";";
        return SD

    def identifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'identifier', [])
        ID = self._scan('ID', context=_context)
        ID = ID.replace("$", "_dol_")
        ID = ID.replace("@", "_at_")
        return ID

    def assignment_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'assignment_op', [])
        _token = self._peek('":="', 'r"[*]="', '"/="', '"%="', 'r"[+]="', '"-="', context=_context)
        if _token == '":="':
            self._scan('":="', context=_context)
            return ""
        elif _token == 'r"[*]="':
            self._scan('r"[*]="', context=_context)
            return "*"
        elif _token == '"/="':
            self._scan('"/="', context=_context)
            return "/"
        elif _token == '"%="':
            self._scan('"%="', context=_context)
            return "%"
        elif _token == 'r"[+]="':
            self._scan('r"[+]="', context=_context)
            return "+"
        else: # == '"-="'
            self._scan('"-="', context=_context)
            return "-"

    def list_literal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'list_literal', [])
        self._scan("'\\\\['", context=_context)
        list_plain = self.list_plain(_context)
        self._scan("'\\\\]'", context=_context)
        return '['+list_plain+']'

    def list_plain(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'list_plain', [])
        _token = self._peek("''", 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', context=_context)
        if _token != "''":
            additive_exp = self.additive_exp(_context)
            S = additive_exp
            while self._peek('","', '"\\\\)"', "'\\\\]'", context=_context) == '","':
                self._scan('","', context=_context)
                additive_exp = self.additive_exp(_context)
                S += "," + additive_exp
            return S
        else: # == "''"
            self._scan("''", context=_context)
            return ''

    def additive_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'additive_exp', [])
        term = self.term(_context)
        S = term
        while self._peek("r'[+]'", '"-"', '"\\\\)"', '","', "'to'", "'by '", "''", 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', "'=='", "'!='", "'<'", "'>'", "'<='", "'>='", "'or'", "'xor'", "'\\\\|'", "'\\\\]'", "'and'", 'NEWLINE', context=_context) in ["r'[+]'", '"-"']:
            _token = self._peek("r'[+]'", '"-"', context=_context)
            if _token == "r'[+]'":
                self._scan("r'[+]'", context=_context)
                term = self.term(_context)
                S += "+" + term
            else: # == '"-"'
                self._scan('"-"', context=_context)
                term = self.term(_context)
                S += "-" + term
        return S

    def cast_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'cast_exp', [])
        type_name = self.type_name(_context)
        while 1:
            self._scan('"\\\\("', context=_context)
            if self._peek('"\\\\("', 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', context=_context) != '"\\\\("': break
        while 1:
            additive_exp = self.additive_exp(_context)
            if self._peek('INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', '"\\\\)"', '","', "'to'", "'by '", "''", "'=='", "'!='", "'<'", "'>'", "'<='", "'>='", "'or'", "'xor'", "'\\\\|'", "'\\\\]'", "'and'", 'NEWLINE', context=_context) not in ['INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("']: break
        self._scan('"\\\\)"', context=_context)
        return type_name+"("+additive_exp+")";

    def term(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'term', [])
        factor = self.factor(_context)
        S = factor
        while self._peek("r'[*]'", '"/"', '"%"', "r'[+]'", '"-"', '"\\\\)"', '","', "'to'", "'by '", "''", 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', "'=='", "'!='", "'<'", "'>'", "'<='", "'>='", "'or'", "'xor'", "'\\\\|'", "'\\\\]'", "'and'", 'NEWLINE', context=_context) in ["r'[*]'", '"/"', '"%"']:
            _token = self._peek("r'[*]'", '"/"', '"%"', context=_context)
            if _token == "r'[*]'":
                self._scan("r'[*]'", context=_context)
                factor = self.factor(_context)
                S += "*" + factor
            elif _token == '"/"':
                self._scan('"/"', context=_context)
                factor = self.factor(_context)
                S += "/" + factor
            else: # == '"%"'
                self._scan('"%"', context=_context)
                factor = self.factor(_context)
                S += "%" + factor
        return S

    def factor(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'factor', [])
        _token = self._peek('INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', context=_context)
        if _token == 'INT':
            INT = self._scan('INT', context=_context)
            return INT
        elif _token == 'REAL':
            REAL = self._scan('REAL', context=_context)
            return REAL
        elif _token == "'\\\\['":
            list_literal = self.list_literal(_context)
            return list_literal
        elif _token == 'STRING':
            STRING = self._scan('STRING', context=_context)
            return STRING
        elif _token == 'ID':
            identifier = self.identifier(_context)
            A = identifier
            _token = self._peek('"\\\\("', "''", context=_context)
            if _token == '"\\\\("':
                self._scan('"\\\\("', context=_context)
                list_plain = self.list_plain(_context)
                self._scan('"\\\\)"', context=_context)
                return A + "("+list_plain+")"
            else: # == "''"
                self._scan("''", context=_context)
                return A
        elif _token != '"\\\\("':
            cast_exp = self.cast_exp(_context)
            return cast_exp
        else: # == '"\\\\("'
            self._scan('"\\\\("', context=_context)
            additive_exp = self.additive_exp(_context)
            self._scan('"\\\\)"', context=_context)
            return additive_exp

    def fcn_definition(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'fcn_definition', [])
        self._scan('"fcn"', context=_context)
        type_name = self.type_name(_context)
        fcn_name = self.fcn_name(_context)
        self._scan('"\\\\("', context=_context)
        param_list = self.param_list(_context)
        self._scan('"\\\\)"', context=_context)
        P1 = ""
        for x in param_list: P1+=x[1]
        S = "\ndef " + fcn_name + "(" + P1 + "):"
        compound_statement = self.compound_statement(_context)
        S += compound_statement
        global header
        header += S
        return ""

    def param_list(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'param_list', [])
        _token = self._peek("'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', "''", context=_context)
        if _token != "''":
            type_name = self.type_name(_context)
            identifier = self.identifier(_context)
            S = [(type_name, identifier)]
            while self._peek('","', '"\\\\)"', context=_context) == '","':
                self._scan('","', context=_context)
                type_name = self.type_name(_context)
                identifier = self.identifier(_context)
                S.append((type_name, identifier))
            return S
        else: # == "''"
            self._scan("''", context=_context)
            return []

    def compound_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'compound_statement', [])
        NEWLINE = self._scan('NEWLINE', context=_context)
        S = ""
        while self._peek('END_BLOCK', 'INDENT', context=_context) == 'INDENT':
            INDENT = self._scan('INDENT', context=_context)
            statement = self.statement(_context)
            NEWLINE = self._scan('NEWLINE', context=_context)
            S += statement
        END_BLOCK = self._scan('END_BLOCK', context=_context)
        return S + "\n"

    def p_compound_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'p_compound_statement', [])
        NEWLINE = self._scan('NEWLINE', context=_context)
        S = ""
        while self._peek('INDENT', "'while'", "'elseif'", "'else'", 'END_BLOCK', context=_context) == 'INDENT':
            INDENT = self._scan('INDENT', context=_context)
            statement = self.statement(_context)
            NEWLINE = self._scan('NEWLINE', context=_context)
            S += statement
        return S

    def jump_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'jump_statement', [])
        _token = self._peek("'conclude'", "'next'", "'stop'", context=_context)
        if _token == "'conclude'":
            self._scan("'conclude'", context=_context)
            S = "return "
            _token = self._peek("''", 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', context=_context)
            if _token != "''":
                additive_exp = self.additive_exp(_context)
                S += additive_exp
            else: # == "''"
                self._scan("''", context=_context)
                S += ""
            return S
        elif _token == "'next'":
            self._scan("'next'", context=_context)
            return "continue"
        else: # == "'stop'"
            self._scan("'stop'", context=_context)
            return "break"

    def fcn_name(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'fcn_name', [])
        identifier = self.identifier(_context)
        return identifier

    def conditional_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'conditional_statement', [])
        self._scan("'if'", context=_context)
        self._scan("'\\\\|'", context=_context)
        boolean_exp = self.boolean_exp(_context)
        self._scan("'\\\\|'", context=_context)
        S = "if "+boolean_exp+":"
        p_compound_statement = self.p_compound_statement(_context)
        S += p_compound_statement
        while self._peek("'else'", 'END_BLOCK', "'elseif'", context=_context) == "'elseif'":
            self._scan("'elseif'", context=_context)
            self._scan("'\\\\|'", context=_context)
            boolean_exp = self.boolean_exp(_context)
            self._scan("'\\\\|'", context=_context)
            S += "elif "+boolean_exp+":"
            p_compound_statement = self.p_compound_statement(_context)
            S += p_compound_statement
        _token = self._peek("'else'", 'END_BLOCK', context=_context)
        if _token == "'else'":
            self._scan("'else'", context=_context)
            S += "else:"
            compound_statement = self.compound_statement(_context)
            S += compound_statement
        else: # == 'END_BLOCK'
            END_BLOCK = self._scan('END_BLOCK', context=_context)
        return S

    def boolean_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'boolean_exp', [])
        _token = self._peek("'yes'", "'no'", 'INT', 'REAL', "'\\\\['", 'STRING', 'ID', "'void'", "'bool'", "'int'", "'real'", "'str'", "'array'", "'structure'", "'enum'", 'TYPE', '"\\\\("', context=_context)
        if _token not in ["'yes'", "'no'"]:
            logical_and_exp = self.logical_and_exp(_context)
            return logical_and_exp
        elif _token == "'yes'":
            self._scan("'yes'", context=_context)
            return '1'
        else: # == "'no'"
            self._scan("'no'", context=_context)
            return '0'

    def logical_and_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'logical_and_exp', [])
        logical_or_exp = self.logical_or_exp(_context)
        S = logical_or_exp
        while self._peek("'and'", "'\\\\|'", context=_context) == "'and'":
            self._scan("'and'", context=_context)
            S += ' and '
            logical_or_exp = self.logical_or_exp(_context)
            S += logical_or_exp
        return S

    def logical_or_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'logical_or_exp', [])
        relational_exp = self.relational_exp(_context)
        S = "("+relational_exp
        while self._peek("'or'", "'xor'", "'and'", "'\\\\|'", context=_context) in ["'or'", "'xor'"]:
            _token = self._peek("'or'", "'xor'", context=_context)
            if _token == "'or'":
                self._scan("'or'", context=_context)
                S += ' or '
            else: # == "'xor'"
                self._scan("'xor'", context=_context)
                S += ' xor '
            relational_exp = self.relational_exp(_context)
            S += relational_exp
        return S+")"

    def relational_exp(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'relational_exp', [])
        additive_exp = self.additive_exp(_context)
        S = additive_exp
        relational_op = self.relational_op(_context)
        S += relational_op
        additive_exp = self.additive_exp(_context)
        return S + additive_exp

    def relational_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'relational_op', [])
        _token = self._peek("'=='", "'!='", "'<'", "'>'", "'<='", "'>='", context=_context)
        if _token == "'=='":
            self._scan("'=='", context=_context)
            return '=='
        elif _token == "'!='":
            self._scan("'!='", context=_context)
            return '!='
        elif _token == "'<'":
            self._scan("'<'", context=_context)
            return '<'
        elif _token == "'>'":
            self._scan("'>'", context=_context)
            return '>'
        elif _token == "'<='":
            self._scan("'<='", context=_context)
            return '<='
        else: # == "'>='"
            self._scan("'>='", context=_context)
            return '>='

    def iterative_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'iterative_statement', [])
        _token = self._peek("'for'", "'while'", "'loop'", context=_context)
        if _token == "'for'":
            self._scan("'for'", context=_context)
            self._scan("'\\\\|'", context=_context)
            S = "for "
            identifier = self.identifier(_context)
            S += identifier
            self._scan("':='", context=_context)
            S += " in range("
            additive_exp = self.additive_exp(_context)
            S += additive_exp
            self._scan("'to'", context=_context)
            additive_exp = self.additive_exp(_context)
            S += "," + additive_exp
            _token = self._peek("'by '", "''", context=_context)
            if _token == "'by '":
                self._scan("'by '", context=_context)
                additive_exp = self.additive_exp(_context)
                S += "," + additive_exp
            else: # == "''"
                self._scan("''", context=_context)
            self._scan("'\\\\|'", context=_context)
            S += "):"
            compound_statement = self.compound_statement(_context)
            S += compound_statement
            return S
        elif _token == "'while'":
            self._scan("'while'", context=_context)
            self._scan("'\\\\|'", context=_context)
            S = "while("
            boolean_exp = self.boolean_exp(_context)
            S += boolean_exp
            self._scan("'\\\\|'", context=_context)
            S += "):"
            compound_statement = self.compound_statement(_context)
            S += compound_statement
            return S
        else: # == "'loop'"
            self._scan("'loop'", context=_context)
            S = "dwf = 1;"
            p_compound_statement = self.p_compound_statement(_context)
            self._scan("'while'", context=_context)
            self._scan("'\\\\|'", context=_context)
            S += "while("
            boolean_exp = self.boolean_exp(_context)
            S += boolean_exp
            self._scan("'\\\\|'", context=_context)
            S += " and dwf):"
            S += "dwf = 0;" + p_compound_statement
            return S


def parse(rule, text):
    P = Prodo(ProdoScanner(text))
    return runtime.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps


